###############################################################################
#  OptimOTU metabarcoding bioinformatics pipeline                             #
#             Configuration file                                              #
###############################################################################

# General parameters
project_name: metabarcoding_project

# Files to work with. Specify the extension, e.g. fastq.gz / fq.gz / fastq / fq.
# The default selects any of these
# Regular expression syntax is allowed.
# Only used if no custom sample table is given.
file_extension: "fastq.gz"

# Specify sequence orientation.
  # "fwd" = all sequences are expected to be in 5'-3' orientation.
  # "rev" = all sequences are expected to be in 3'-5' orientation.
  # "mixed" = the orientation of seqs is expected to be mixed (5'-3' and 3'-5)
  # "custom" = the orientation of different files is given in a custom sample table (see below)
  #   In this case there should be a column "orient" which has values "fwd", "rev", or "mixed"
  # if seqs are "mixed", but using "fwd" setting, then some valid seqs (or samples) will be lost.
  # if seqs are "fwd", but using "mixed", then ERROR.
orient: fwd

# Sample parameters
# custom primer trimming parameters per sample can be given as columns in the
# sample table.
custom_sample_table: FALSE

# Added reference sequences (leave blank or use NULL if none)
# "table" should be an Excel *.xlsx spreadsheet, with (at least) two columns in the
# first sheet:
#  Culture_ID: unique identifier for the sequence, muse _exactly_ match the sequence
#    name in "fasta"
#  Protax_synonym: comma-separated taxonomy string for the new ID, starting with
#    kingdom.  Be sure to match the taxonomy used by protax, including spelling!
#    e.g.: Fungi,Basidiomycota,Agaricomycetes,Russulales,Stereaceae,Conferticium_17349,Conferticium_ravum_412824
added_reference:
  fasta:
  table:

############################
### parallelism settings ###
############################

# max number of threads to use in local processes
# set this lower than your actual number of CPUs if you need to reduce
# RAM usage
# local_threads: 8

# maximum number of ASV sequences to process in a single batch
max_batchsize: 10000

# for parallel execution (crew or clustermq) how many workers to launch for
# each sequencing run and orientation. 2 will yield maximum parallelism in most
# situations.
workers_per_seqrun: 2

# regardless of the number of sequencing runs, the maximum and minimum number of
# parallel jobs to run. For crew, the number of jobs actually launched may be
# less than min_jobs if additional jobs would have nothing to do.
max_jobs: 100
min_jobs: 1

################################
### primer trimming settings ###
################################

#forward PCR primer (degenerate positions allowed, according to IUPAC codes).
#Currently supports only a single fwd primer.
forward_primer: "GCATCGATGAAGAACGCAGC" #ITS3
#reverse PCR primer (degenerate positions allowed, according to IUPAC codes).
#Currently supports only a single rev primer.
reverse_primer: "TCCTCCGCTTATTGATATGC" #ITS4

trimming:
  max_err: 0.2        # max error rate (float; e.g 0.2 = 20% error rate) in the primer sequence; or number of mismatches (int; e.g. 1 = 1 mismatch)
  min_overlap: 10     # at least 10 bp of primer sequence must be present
  truncQ_R1: [2, 2]   # truncate ends of R1 at first base with quality score <= N
  truncQ_R2: [2, 2]   # truncate ends of R2 at first base with quality score <= N
  max_n: 0            # remove sequences which contain N (after truncation)
  min_length: 100     # min length after adapter/quality trimming
  cut_R1: 0           # remove N bases from start of R1
  cut_R2: 0           # remove N bases from start of R2
  action: "trim"      # "trim"/"retain" the primer sequences. "trim" = clip primers; "retain" = do not clip the primer after primer has been found.

##################################
### quality filtering settings ###
##################################
filtering:
  maxEE_R1: 1           # max expected errors for R1 reads
  maxEE_R2: 1           # max expected errors for R2 reads

####################################
### tag-jumps filtering settings ###
####################################
# comment out this section or set tag_jump to FALSE to omit this step
tag_jump:
  f: 0.05             # expected cross-talk rate
  p: 1                # power to rise the exponent

#########################################
### LULU secondary denoising settings ###
#########################################
# Secondary denoising attempts to remove ASVs which are caused by rare
# sequencing errors or (more likely) early-cycle PCR errors. These may be more
# abundant than predicted by the error model used by DADA2 for denoising.
#
# LULU identifies potential "daughter" sequences which were produced as errors
# from a "parent" sequence, based on co-occurrence in the same samples and
# relative abundance. Typically the daughter sequence would only be present in
# samples where the parent sequence is also present, and at lower abundance.
#
# Pairwise distances for LULU may be calculated by the same methods as used for
# clustering; but it may be useful to use different settings for LULU. In
# particular, Illumina sequencers make mostly substitution errors, while some
# marker regions (notably ITS) display frequent indel mutations between species
# and even haplotypes, so limiting the number of gaps allowed in the alignment
# may improve the precision of LULU.
#
# comment out this section or set lulu to FALSE to omit this step
lulu:
  dist_type: fraction   # "fraction", "score", or "base"; default is fraction
  max_dist: 0.1         # max pairwise distance for parent-daughter candidates
  max_gap_length: 1     # max length of each gap in parent-daughter alignments
  max_gap_total: 3      # max total number of gaps in parent-daughter alignments
  min_abundance_ratio: 1 # parent must be _more_ than this * daughter
  min_cooccurrence_ratio: 1 # parent must cooccur in _at least_ this * daughter occurrences
  use_mean_abundance_ratio: no # if yes/true, min_abundance_ratio applies to mean over all samples, rather than each sample
  dist_config:
    method: usearch # see clustering options below
    usearch: bin/usearch

###############################
### Amplicon model settings ###
###############################
# comment out this section or set model_type to "none" to skip this step
# statistical sequence models are used for several purposes:
#  1) aligning ASVs prior to use of protaxA and/or NuMt detection
#  2) filtering ASVs to remove spurious sequences
amplicon_model:
  model_type: CM      # allowed values are CM, HMM, and none
  model_file: data/ITS3_ITS4.cm

  # model filter will be skipped if amplicon_model$model_type is "none",
  # or if this section is commented out.
  # these values will need to be tuned for different amplicons/models
  model_filter:
    max_model_start: 5    # the match must start at this point in the model or earlier
    min_model_end: 140    # the match must end at this point in the model or later
    min_model_score: 50   # the match bit score must be at least this

  # producing aligned sequences will be skipped if the value is false
  model_align: no

  # numt filter will be skipped if the value is false
  # numt filter requires model_type == "HMM" and model_align == TRUE
  numt_filter: no

#########################
### OTU table options ###
#########################
# The default output is a "long" OTU table, where each row represents the
# occurrence of one OTU in one sample; the columns are "seq_id", "sample",
# "seqrun", "nread", and "fread". "nread" and "fread" are never 0; sample-OTU
# combinations which were not observed are simply omitted.
# This is also called the "sparse" OTU table, because it is a format which is
# well-suited to sparse matrices, such as essentially all OTU tables in
# practice.

# It is possible to, in addition, output a "wide" OTU table, where each row is
# a sample (sample + seqrun above), each column is an OTU (seq_id above), and
# the entries are the number of reads (nread above). For most datasets, this
# representation is much larger when uncompressed, and for some datasets it is
# not possible to even fit it in memory.  However, many community ecology
# analysis tools only accept the output in "wide" format, so it is available as
# an option.
wide_table: no

#########################
### Control sequences ###
#########################
# Two types of control sequences are supported:
# 1) spike-in sequences: sequences that are added to the samples before PCR
#    These sequences are expected to be present in every sample, even
#    most types of negative control.
# 2) positive control sequences: sequences that are added to only a few specific
#    positive control samples.  These sequences are expected to be present only
#    in the positive control samples, and their presence in other samples is
#    indicative of cross-contamination. (Either in the lab or "tag-switching").
# In practice both types are treated the same by the pipeline, they are just
# reported separately.
#
# The sequences should be in a fasta file.
# Either or both type of control can be omitted by leaving the value blank,
# omitting it completely, or setting it to a value that evaluates to false.
control:
  spike: protaxFungi/addedmodel/amptk_synmock.fasta
  positive: no

#########################
### Taxonomy settings ###
#########################
# Currently four different taxonomic classifiers are implemented: Protax,
# Sintax, BayesANT, and EPA-ng + Gappa.
#
# Only one of those sections should be given; the others should be commented
# out.

taxonomy:
  #### Protax: probabilistic taxonomic classifier ####
  ## Distinguishes "novel taxon" from "uncertain classification"
  ## Training is not (yet) supported in the pipeline
  ## The "aligned" version is much faster if the sequences can be universally
  ## aligned
  protax:
    aligned: no # "yes" assumes all reference and query sequences are aligned
    location: "protaxFungi" # directory where protax is

  # #### SINTAX: simple non-Bayesian taxonomic classifier ####
  # ## A fast taxonomic classifier that gives reasonably well-calibrated
  # ## confidence estimates (at least above 50%). It does not require
  # ## pre-training, only a correctly formatted database (either FASTA or UDB).
  # ## Only unaligned sequences are supported.
  # sintax:
  #   reference: "protax"
  #
  # #### BayesANT: Bayesian non-parametric taxonomic classifier ####
  # ## Distinguishes "novel taxa" from "uncertain classification"
  # ## Like Protax, it has an aligned an an unaligned version.
  # ## Training is supported, in which case supply reference
  # ## Alternatively a pretrained model may be supplied as an R object saved to
  # ## a file in RDS, QS, or QS2 format.
  # bayesant:
  #   aligned: no # "yes" assumes all reference and query sequences are aligned
  #   reference: "path/to/ref.fasta"
  #   # model: "path/to/model.qs2"
  #
  # #### EPA-ng: evolutionary placement algorithm - next generation ####
  # ## A phylogenetic placement algorithm.
  # ## Postprocessing with Gappa summarizes the results as probabilistic
  # ## taxonomic identifications, including distinction between "novel taxa" and
  # ## "uncertain classification".
  # ## Can only be used with aligned reference and query sequences.
  # ## Training is not performed by the pipeline.
  # ## Requires as input a reference alignment, taxonomy for the reference
  # ## alignment, a phylogenetic tree based on the reference alignment, the
  # ## fitted model parameters for the tree, and an outgroup.
  # epa:
  #   # reference should be an aligned fasta file, with sequence identifier only
  #   # as the header
  #   reference: "path/to/ref.fasta"
  #   # tab-separated, first column is identifiers (as in reference), second
  #   # column is ??-separated taxonomy string
  #   taxonomy: "path/to/taxonomy.tsv"
  #   # tip labels should match the sequence identifiers in the reference
  #   tree: "path/to/tree.newick"
  #   # the model specification can be given explicitly, or a file name can be
  #   # supplied.  EPA-ng can parse log files from RAxML and IQTREE (VeryFastTree?)
  #   params: "GTR{x,y,z,a,b,c}+F{d,e,f,g}+G{h}"
  #   # Supply either:
  #   #  1) the name of a taxon from taxonomy:, in which case that taxon must form
  #   #     a monophyletic group in the tree
  #   #  2) a list of one or more sequence identifiers, in which case those
  #   #     sequences must form a monophyletic group in the tree
  #   #  3) the name of a file containing such a list of sequence identifiers,
  #   #     one per line.
  #   outgroup: "Arachnida"

  #### Ranks ####
  # Ranks should be listed from most inclusive to lease inclusive.
  # The first rank(s) may be given with values (e.g. "- kingdom: Fungi" instead
  # of just "- kingdom"). This means that the rank(s) are not assigned by
  # the classifier, but rather are assumed to already be known; i.e. they are
  # the root of the classification.

  ranks:
    - kingdom: Fungi
    - phylum
    - class
    - order
    - family
    - genus
    - species

###################################
### Outgroup reference settings ###
###################################
# The outgroup reference should be taxonomically annotated sequences which
# include not only the ingroup (i.e., those sequences which Protax can identify)
# but also (ideally) all other groups which could conceivably be encountered
# with the chosen marker.
# Optionally, the taxonomic annotations can be given in another file.
# (The formatting in this case is idiosyncratic, related to the release format
# of Unite.)
# If given, this is also the file used for reference-based chimera checking.
outgroup_reference:
  sequences: data/sh_matching_data/sanger_refs_sh.fasta
  taxonomy: data/sh_matching_data/shs_out.txt

###########################
### Clustering settings ###
###########################
# `thresholds` can be specified in two different ways:
# 1) a file name tor a TSV file giving pre-computed thresholds
# 2) parameters for optimizing the thresholds (unimplemented in current version)
#
# `measure` is the abbreviation of one of the clustering measures which can be
# calculated by `optimotu::optimize_thresholds()`. These are:
#   MCC: Matthews correlation coefficient
#   RI: Rand index (not recommended)
#   ARI: adjusted Rand index
#   FMI: Fowlkes-Mallow index
#   MI: mutual information (not recommended)
#   AMI: adjusted mutual information
#   FM: (multiclass) F-measure
# This is only necessary if optimizing new thresholds, or if the pre-computed
# thresholds include optima for several different measure
#
# `dist_config` gives the method for calculating pairwise distances between
# sequences when clustering. It can be a single value naming one of the methods
# supported by `optimotu::dist_config()`, typically "hamming", "wfa2", or
# "usearch"; or alternatively it can be several values, which are passed on to
# `optimotu::dist_config()`.  For instance:
#
#   dist_config:
#     method: wfa2
#     match: 0
#     mismatch: 3
#     gap_open: 3
#     gap_extend: 1
#
# Note that "hamming" requires "model_align: true" (see above) and "usearch"
# (the default) requires the usearch program to be installed.
clustering:
  thresholds: metadata/GSSP_thresholds.tsv
  measure: FM
  dist_config:
    method: usearch
    usearch: bin/usearch

######################
### Guild settings ###
######################
guilds: no

############################
### Rarefaction settings ###
############################
# Rarefaction can be specified either by numerator and denominator or by number
# Numerator and number (but not denominator) can have multiple values given in square brackets.
# e.g. numerator: [1, 3, 10, 30, 100]
# rarefy:
#   number: [50, 100]
